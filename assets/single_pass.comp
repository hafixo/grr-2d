#version 450 core
#extension GL_KHR_shader_subgroup_ballot : enable

layout (local_size_x = 8, local_size_y = 4) in;

layout (location = 0) uniform uint u_num_entities;

layout (binding = 0, rgba32f) uniform image2D u_color_target;

struct Entity {
    uint type;
    uint _pad0;
};
struct Circle {
    uint type;
    uint color;
};

layout (binding = 0, std430) readonly buffer SceneBounds {
    vec4 bboxes[];
};
layout (binding = 1, std430) readonly buffer SceneEntities {
    Entity entities[];
};
layout (binding = 2, std430) readonly buffer SceneCircle {
    Circle circles[];
};

shared uint tile_cache[32];

void main() {
    const uint lane_id = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;
    const vec2 tile_dim = vec2(4.0, 2.0); // viewport settings
    const vec2 tile_pos = vec2(gl_WorkGroupID.x * tile_dim.x, gl_WorkGroupID.y * tile_dim.y);
    const vec2 fragment_dim = tile_dim / gl_WorkGroupSize.xy;
    const vec2 fragment_pos = vec2(gl_GlobalInvocationID.x * fragment_dim.x, gl_GlobalInvocationID.y * fragment_dim.y);
    const vec2 fragment_center = fragment_pos + 0.5 * fragment_dim;

    vec4 color = vec4(0.2, 0.0, 0.0, 0.0);
    for (uint e = 0; e < u_num_entities; e += 32) {
        // coarse culling based on bounding box
        // tile level
        const uint ti = e + lane_id;
        bool hit = false;
        if (ti < u_num_entities) {
            const vec4 bbox = bboxes[ti];
            hit = all(bvec4(lessThan(bbox.xy, tile_pos + tile_dim), greaterThan(bbox.zw, tile_pos)));
        }
        const uvec4 hitBallot = subgroupBallot(hit);
        const uint write_index = subgroupBallotExclusiveBitCount(hitBallot);
        if (hit) {
            tile_cache[write_index] = ti;
        }

        const uint tile_cache_size = subgroupBallotBitCount(hitBallot);
        for (uint i = 0; i < tile_cache_size; i++) {
            uint entity_id = tile_cache[i];
            uint entity_ty = entities[entity_id].type;
            switch (entity_ty) {
            case 0x1: {
                vec4 bbox = bboxes[entity_id];
                vec2 position = (bbox.xy + bbox.zw) / 2.0;
                float radius = position.x - bbox.x;

                float dist = length(fragment_center - position);
                float alpha = clamp(radius - dist, 0.0, 1.0);
                vec4 circle_color = unpackUnorm4x8(circles[entity_id].color);
                color += circle_color * circle_color.a * alpha;
            } break;
            }
        }
    }
    imageStore(u_color_target, ivec2(gl_GlobalInvocationID.xy), color);
}

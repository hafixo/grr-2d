#version 450 core

layout (local_size_x = 32, local_size_y = 8) in;

layout (binding=0, rgba32f) uniform image2D u_color_target;

void deserialize_circle(uvec4 data, out vec2 position, out float radius, out vec4 color) {
    vec4 bbox = vec4(unpackHalf2x16(data.y), unpackHalf2x16(data.z));
    position = (bbox.xy + bbox.zw) / 2.0;
    radius = position.x - bbox.x;
    color = unpackUnorm4x8(data.w);
}

layout (binding = 0, std430) buffer TileCommand {
    uvec4 data[];
};

void main() {
    const uint tileID = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x
     + gl_NumWorkGroups.x * gl_NumWorkGroups.y * gl_WorkGroupID.z;

    const uint max_ops = 128 / 16;
    uint dst = max_ops * tileID;

    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
    const vec2 fragment_dim = vec2(16.0 / 32.0, 4.0 / 8.0); // viewport settings
    const vec2 fragment_pos = vec2(gl_GlobalInvocationID.x * fragment_dim.x, gl_GlobalInvocationID.y * fragment_dim.y);
    const vec2 fragment_center = fragment_pos + 0.5 * fragment_dim;

    for (int i = 0;; i++) {
        uvec4 op = data[dst + i];
        uint command = op.x;

        if (command == 0xFF) {
            break;
        }

        switch (command) {
        case 0x1: {
            vec2 position = vec2(0.0);
            float radius = 0.0;
            vec4 circle_color = vec4(0.0);
            deserialize_circle(op, position, radius, circle_color);

            float dist = length(fragment_center - position);
            float alpha = clamp(radius - dist, 0.0, 1.0);
            color += circle_color * circle_color.a * alpha;
        } break;
        }
    }

    imageStore(u_color_target, ivec2(gl_GlobalInvocationID.xy), color);
}

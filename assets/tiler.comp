#version 450 core

layout (local_size_x = 1) in;

struct Entity {
    uint type;
    uint _pad0;
};
struct Circle {
    uint type;
    uint color;
};

layout (location = 0) uniform uint u_num_entities;

layout (binding = 0, std430) readonly buffer SceneBounds {
    vec4 bboxes[];
};

layout (binding = 1, std430) readonly buffer SceneEntities {
    Entity entities[];
};
layout (binding = 2, std430) readonly buffer SceneCircle {
    Circle circles[];
};

layout (binding=0, rgba32f) uniform image2D u_color_target;

uvec4 serialize_end() {
    return uvec4(0xFF);
}

uvec4 serialize_circle(vec4 bbox, uint color) {
    return uvec4(0x1, packHalf2x16(bbox.xy), packHalf2x16(bbox.zw), color);
}

layout (binding = 3, std430) buffer TileCommand {
    uvec4 data[];
};

void main() {
    const uint invocationID = gl_GlobalInvocationID.x +
        gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

    const uint max_ops = 128 / 16;
    uint dst = max_ops * invocationID;

    const vec2 tile_dim = vec2(16.0, 4.0); // viewport settings
    const vec2 tile_pos = vec2(gl_GlobalInvocationID.x * tile_dim.x, gl_GlobalInvocationID.y * tile_dim.y);
    const vec2 tile_center = tile_pos + 0.5 * tile_dim;

    imageStore(u_color_target, ivec2(gl_GlobalInvocationID.xy), vec4(tile_center / 400.0, 0.0, 1.0));

    uint num_ops = 0;
    for (uint i = gl_LocalInvocationID.x; i < u_num_entities; i += 1) {
        vec4 bbox = bboxes[i];
        bool hit = all(bvec4(lessThan(bbox.xy, tile_pos + tile_dim), greaterThan(bbox.zw, tile_pos)));
        if (!hit) {
            continue;
        }

        uint type = entities[i].type;
        switch (type) {
        case 0x1: {
            data[dst + num_ops] = serialize_circle(bbox, circles[i].color);
            num_ops += 1;
        } break;
        }
    }
    data[dst + num_ops] = serialize_end();
}